# mini_shell

간단한 Unix 스타일의 쉘 구현 프로젝트입니다.
사용자 입력을 받아 외부 명령어를 실행하고, 내장 명령어(`cd`, `exit`, `help`, `history`)도 직접 처리합니다.

---

## 실행 방법

```bash
gcc -o mini_shell mini_shell.c
./mini_shell
```

---

## 주요 기능

- `$` 프롬프트 출력
- 사용자 명령어 입력 받기
- `fork()`와 `execvp()`를 이용해 외부 명령어 실행
- `wait()`으로 자식 프로세스 종료 대기
- 내장 명령어 처리 (`cd`, `exit`, `help`, `history`)

---

## 핵심 시스템 콜 구조

### 1. `fork()` + `exec()` 모델

쉘이 외부 명령어를 실행하는 방식은 다음과 같은 **고전적인 프로세스 생성 패턴**입니다

```c
pid_t pid = fork();

if (pid == 0) {
    // 자식 프로세스: 명령어 실행
    execvp(args[0], args);
    perror("exec failed");
    exit(1);
} else if (pid > 0) {
    // 부모 프로세스: 자식 종료 대기
    wait(NULL);
}
```

#### 동작 흐름 요약

1. `fork()`로 부모 프로세스(쉘)가 자식 프로세스를 생성
2. 자식 프로세스는 `exec()`로 새로운 프로그램(명령어)을 덮어쓰기
3. 부모는 `wait()`으로 자식의 종료를 대기
4. 자식이 종료되면 `SIGCHLD` 시그널이 발생, 부모가 이를 수거함

### 2. 왜 이렇게 나눠야 할까?

- `exec()`는 호출된 프로세스를 **완전히 덮어쓰기** 때문에  
  쉘 자신이 실행하면 **쉘이 사라져버립니다**.
- 그래서 반드시 **`fork()`를 통해 새 프로세스에 명령어를 실행시키고**,  
  쉘(부모)은 남아 있어야 합니다.

---

## 내장 명령어 처리

쉘 명령어 중에는 `cd`, `exit`, `export` 같은 것들이 **실행 파일이 아닌, 쉘 내부 기능**입니다.  
이들은 외부 프로그램이 아니라 쉘이 직접 처리해야 효과가 있으므로, 별도로 구현합니다.

### 구현된 내장 명령어

| 명령어      | 설명                                    |
| ----------- | --------------------------------------- |
| `cd [경로]` | 현재 쉘 프로세스의 작업 디렉토리를 변경 |
| `exit`      | 쉘 종료                                 |
| `help`      | 사용 가능한 내장 명령어 목록 출력       |
| `history`   | 지금까지 실행한 명령어 목록 출력        |

### 내부 구조

- 쉘 내부에서 `"cd"`, `"exit"` 등으로 시작하는 명령어인지 먼저 검사하고
- 외부 명령어 실행(fork+exec)을 하지 않고 쉘 내부에서 직접 실행
- 내장 명령어는 함수 포인터 테이블로 관리:

```c
struct builtin_cmd {
    const char *name;
    int (*func)(char **args);
};
```

---

## 학습 포인트

- 프로세스 생성과 프로그램 실행의 차이: `fork()` vs `exec()`
- 부모-자식 프로세스 관계
- 시스템 콜 기반 프로세스 제어
- 쉘과 OS의 상호작용 이해
- 내장 명령어의 의미와 처리 방식

---

## 참고

- 《Operating System Concepts》 – 프로세스 관리 챕터
- man pages: `man fork`, `man execvp`, `man wait`
- Bash 소스코드 (GNU bash) – https://ftp.gnu.org/gnu/bash/

---

## 실제 실행 과정
